\chapter{Architecture}
\section{Backend}
This section discusses the aspects of the contract related to the overall application architecture. Detailed informations about the Solidity \textbf{smart contract} itself can be found in the Section \ref{sec:solidity_contract}. \href{https://hardhat.org/}{Hardhat} was used as the development framework for the smart contract.

\subsection{Contract ABI}

The Contract ABI acts as a function selector, defining the specific methods that can be called to a smart contract for execution. These methods and their associated data types are listed in a generated JSON RPC file.

The Contract ABI is automatically generated by Hardhat and saved in the \texttt{./frontend/src/contracts} folder as \texttt{Mastermind.json}, ensuring that the frontend can use it to interact with the smart contract. This is done by the \texttt{deploy.js} script during the smart contract deployment process.

\subsection{Events}

\ul{The smart contract emits \textit{events} whenever a game action is performed}. This allows the frontend to obtain information about the contract state without explicitly calling getters, enabling asynchronous communication mediated by the smart contract. \\
We strongly advise to \ul{check the \textbf{Appendix} }\ref{fig:mastermind_schema}\ul{ for a flowchart of a game} highlighting how the events influence and model the proceeding of the game\footnote{In the flowchart,  blue squares indicate invocations to contract functions, yellow emitted events, and green user choices}.\\
These emitted events are associated with \textit{event handlers} (see Section \ref{sec:pages}) on the frontend.


%Lo smart contract prevede l'emissione di eventi quando si esegue un'azione di gioco, questo ci ha permesso di avere informazioni sul suo stato senza invocare esplicitamente dei getters, e permettendo la comunicazione asincrona implicata dalla intermediazione dello smart contract.

\section{Frontend}

The frontend was implemented using \href{https://vitejs.dev/}{Vite}, a React framework. Although the frontend consists of many elements and components, this section focuses only on those relevant to the project which concern interacting with the Solidity smart contract.
Detailed discussions about the React page structure, routing, components in the 'misc' folder, CSS, hooks, and other React-related aspects used to compose the frontend are \textbf{not} included.

\subsection{Pages}
\label{sec:pages}

The main logic of the frontend is implemented across two pages: \textbf{Home} and \textbf{Game}. As both pages require interactions with the smart contract, attempting to use them without a connected wallet or without using one of the addresses stored in the wallet will render two respective components: \texttt{NoWalletDetected.jsx} and \texttt{ConnectWallet.jsx}.

After connecting the wallet to the page, a \textbf{provider} is created. This provider is used to interact with the wallet to fetch the selected address, it's balance, and eventually other informations. Additionally, the provider, along with the contract's address and its ABI, is used to define a \texttt{Contract} object in the frontend. This \texttt{Contract} (named \textbf{mastermind}) is used from React to perform explicit calls to the smart contract.

\textbf{Events} emitted by the smart contract enable asynchronous communication from the smart contract to the front end. 
This is also possible thanks to the \texttt{Contract} object, which \ul{listens to those events and associates handlers to execute upon event capture}. Each handler comprises a notification (referenced as a ``snack", see Section \ref{sec:snacks}) to inform the user of the captured event, along with actions necessary to update the page state based on information received from the smart contract. The specific events used on both pages will be listed in their own subsection. When the page is unmounted, a cleanup function is called to remove event listeners.

\subsubsection{Home}

This page serves several purposes: \textbf{creating} a new game (using the \texttt{CreateGameModal.jsx}), displaying \textbf{available} games (including \textit{challenges} to a specific address), and showing games that have already started and can be \textbf{resumed}. \textit{Challenges} to a specific address are indicated by glowing borders around the corresponding React item, and are always prioritized above other available games, as shown in Figure \ref{fig:home}.

Creating a new game involves calling either the \texttt{createGame()} or \texttt{createGameWithJoiner()} smart contract functions, depending on whether the game is directed towards a specific address. Joining a game from the list of available games triggers the \texttt{joinGame()} smart contract function. For more informations, refer to Section \ref{sec:create-join-games}.

\paragraph*{Events listened}

The \textit{events} that the \texttt{Contract} object is set to listen are: 
\begin{itemize}
    \item \textbf{GameCreated} $\rightarrow$ \texttt{handleGameCreated()}: adds to available games the new game created.
    \item \textbf{GameJoined} $\rightarrow$ \texttt{handleGameJoined()}: removes from available games the game joined.
\end{itemize}

\subsubsection{Game}

This is the page used to play Mastermind. Upon loading, it retrieves information about the selected game (from the Home page) calling the \texttt{getGameDetails()} smart contract function. Depending on the fetched information, the player can either act as a \textmauve{Maker} or a \textgreen{Breaker}. Accordingly, either the \textmauve{Maker} board or the \textgreen{Breaker} board component will be displayed, along by other relevant information on the page. An example of how this page appears can be seen in Figure \ref{fig:breaker_secret_code}, which illustrates a case where the \textgreen{Breaker} board is being loaded.

This page contains the invocations of \textit{core} smart contract functions ---discussed in Section \ref{sec:core-functions}--- required to play the game. These functions are passed as references to the board components, enabling the buttons within the boards to execute fundamental game actions.

The function for computing the hash of the secret code is called \texttt{computeHash()} (more on this in Sec. \ref{sec:secret_hash}), and takes as input the secret code and a random salt, which will both need to be exhibited on the end of a turn.
Since it is desirable to store them in the client ---to automatically insert them in end-turn phase---, they \textit{cannot} be simply assigned to a variable, because they must \textit{persist} even in case of page reload and cannot be retrieved from the blockchain, since they are not there.
For this reason they are stored in the browser's \texttt{localStorage} by the functions \texttt{setCodeSecretMemo()} and \texttt{setCodeSeedMemo()}. 

\paragraph*{Events listened}

The \textit{events} that the \texttt{Contract} object is set to listen may vary depending on the role of the player; they are listed below for each scenario:

{Either \textmauve{Maker} or \textgreen{Breaker}:
\ns\begin{itemize}
    \item \textbf{TurnEnded} $\rightarrow$ \texttt{handleTurnEnded()}: sets the flag \texttt{\_turnEnded} = true.
    \item \textbf{GameEnded} $\rightarrow$ \texttt{handleGameEnded()}: resets persistent information (\texttt{Memo}) stored about the code, displays the \texttt{NonClosableModal.jsx} with game result informations, and then sets the flag \texttt{\_gameEnded} = true
    \item \textbf{AFKAccusation} $\rightarrow$ \texttt{handleAFKAccusation()}: sets an object (\texttt{\_accusedAFK}) that contains the address of the accused opponent.
    \item \textbf{ResolveDispute} $\rightarrow$ \texttt{handleResolveDispute()}: sets the flag \texttt{\_disputed} = true and generates the end game message.
\end{itemize}}

{Player acting as \textmauve{Maker}:
\ns\begin{itemize}
    \item \textbf{Guess} $\rightarrow$ \texttt{handleGuess()}: sets an object (\texttt{\_lastGuess}) containing the new guess, and removes the object associated with the AFK accusation.
    \item \textbf{TurnStarted} $\rightarrow$ \texttt{handleTurnStarted()}: sets the flag (\texttt{\_turnStarted}), removes the object associated with the AFK accusation, and calls the function to setup a new turn.
\end{itemize}}

{Player acting as a \textgreen{Breaker}:
\ns\begin{itemize}
    \item \textbf{Feedback} $\rightarrow$ \texttt{handleFeedback()}: sets an object (\texttt{\_lastFeedback}) containing the new feedback, and removes the object associated with the AFK accusation.
    \item \textbf{HashPublished} $\rightarrow$ \texttt{handleHashPublished()}: sets a string (\texttt{\_codeHash}) that contains the hash of the secret code, and removes the object related to the AFK accusation.
    \item \textbf{CodeSecretPublished} $\rightarrow$ \texttt{handleCodeSecretPublished()}: sets an object (\texttt{\_codeSecret}) that contains the secret code, and removes the object related to the AFK accusation.
\end{itemize}}

\note{The flags set in the handlers are passed to and used from the boards to detect specific events in order to act accordingly.}

\subsection{Components}

\subsubsection{Boards}

Core components of the Game page, allow to display the board of the current game (as shown in Figure \ref{fig:breaker_secret_code}). There are two boards: \texttt{BoardMaker.jsx} and \texttt{BoardBreaker.jsx}. Each board displays different buttons based on the possible actions of the \textmauve{maker} and the \textgreen{breaker}.
The \textmauve{Maker} Board includes an additional element that shows the code selected by the \textmauve{maker} at the beginning of the game. This code is only revealed on the \textgreen{Breaker} Board when the \textmauve{maker} publishes it.

Both boards also provide useful text messages to the player, depending on the current state of the turn.

\subsubsection{Modals}

{A modal in React is a component that overlays other content on a webpage. The following modals are used in the frontend:
\ns
\begin{itemize}
    \item \texttt{CreateGameModal.jsx} contains a form that collects informations for creating a new game, such as the game stake and optionally an address to challenge. When the form is submitted, the submit button triggers a function on the Home page that calls the smart contract function to create the game.
    \item \texttt{ColorChoseModal.jsx} contains a form for submitting a color combination. This modal is used by the \textmauve{Maker} Board to create the secret code (see Figure \ref{fig:maker_secret_code}) and by the \textgreen{Breaker} Board to submit guesses.
    \item \texttt{ProvideFeedbackModal.jsx} contains a form for submitting a feedback related to the last guess.
    \item \texttt{NonClosableModal.jsx} is used to display the end game message and includes a button to redirect the player to the Home page, as shown in Figure \ref{fig:win_interface}.
\end{itemize}}

Although the modals containing a form require valid values to be submitted, \ul{any transaction with incorrect values gets \textbf{reverted} by the smart contract, which performs all necessary checks}.

\subsubsection{Snacks}
\label{sec:snacks}

Components named ``snacks" are used to notify the user of any events received from the \textit{smart contract} (as shown in Figure \ref{fig:home} or in Figure \ref{fig:breaker_secret_code}). A global state for storing snacks is maintained, allowing all pages to add a new snack. Only the handlers create new snacks by calling the \texttt{addSnack()} function.
